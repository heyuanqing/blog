二、TCP

TCP 包的大小就应该是 1500 - IP头(20) - TCP头(20) = 1460 (Bytes)

我们在用Socket编程时，UDP协议要求包小于64K。TCP没有限定，TCP包头中就没有“包长度”字段，而完全依靠IP层去处理分帧。这就是为什么TCP常常被称作一种“流协议”的原因，开发者在使用TCP服务的时候，不必去关心数据包的大小，只需讲SOCKET看作一条数据流的入口，往里面放数据就是了，TCP协议本身会进行拥塞/流量控制。



 UDP的系统缓存队列与TCP的相比，有两点显著的不同：

1、UDP没有SendQ。UDP的数据包不会被处理，通过调用sendto()（或者在connect()之后也可以调用send()）将数据直接发送。
2、 UDP的数据在缓存队列中是有边缘保证的，也就是说，数据包是有大小的。每次调用recvfrom()（或者在connect()之后调用recv()）都会试图接收一个完整的数据包——因此，UDP程序所指定的接收缓存大小应该足够存放每一个UDP数据包，否则，多余的部分就会被抛弃，并且 recvfrom()（或recv()）返回一个异常（-1，并且抛出异常代码）。

![](F:\git\Everyday-Learning-Experience\image\linux\TCP\p07.jpg)


（在上图中，我们用虚线的数据包边缘表示TCP中的无边缘保证；而UDP中字节之间用虚线隔开表示UDP的数据不会以字节为单位进行传输）

此外，UDP的RecvQ还可能存在于TCP的第三个不同：我们说，UCP是无连接的，当然，我们也可以调用connect()将UDP连接起来，但是在默认无连接的情况下，UDP的RecvQ中可以缓存来自所有远程地址的数据包——这不仅仅在很多时候很不方便，如果我们只希望接收一个特定地址的数据，比如作为客户端只希望接收来自服务器的数据；而且，因为这个缓存可以被任何信息进入，从而也是一个安全隐患，很可能这个缓存在短时间内就会被垃圾信息所填满。
因此，很多时候我们也会用到“有连接”的UDP。
