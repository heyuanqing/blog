# Shell特殊变量：Shell $0, $#, $*, $@, $?, $$和命令行参数

特殊变量列表

| 变量 | 含义                                                         |
| ---- | :----------------------------------------------------------- |
| $0   | 当前脚本的文件名                                             |
| $n   | 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。 |
| $#   | 传递给脚本或函数的参数个数。                                 |
| $*   | 传递给脚本或函数的所有参数。                                 |
| $@   | 传递给脚本或函数的所有参数。被双引号(" ")包含时，与 $* 稍有不同，下面将会讲到。 |
| $?   | 上个命令的退出状态，或函数的返回值。                         |
| $$   | 当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。 |

## $* 和 $@ 的区别

$* 和 $@ 都表示传递给函数或脚本的所有参数，不被双引号(" ")包含时，都以"$1" "$2" … "$n" 的形式输出所有参数。

但是当它们被双引号(" ")包含时，"$*" 会将所有的参数作为一个整体，以"$1 $2 … $n"的形式输出所有参数；"$@" 会将各个参数分开，以"$1" "$2" … "$n" 的形式输出所有参数。

### 文件描述符

当执行shell命令时，会默认打开3个文件，每个文件有对应的文件描述符来方便我们使用：

| 类型                        | 文件描述符 | 默认情况               | 对应文件句柄位置 |
| --------------------------- | ---------- | ---------------------- | ---------------- |
| 标准输入（standard input）  | 0          | 从键盘获得输入         | /proc/slef/fd/0  |
| 标准输出（standard output） | 1          | 输出到屏幕（即控制台） | /proc/slef/fd/1  |
| 错误输出（error output）    | 2          | 输出到屏幕（即控制台） | /proc/slef/fd/2  |

所以我们平时在执行shell命令中，都默认是从键盘获得输入，并且将结果输出到控制台上。但是我们可以通过更改文件描述符默认的指向，从而实现输入输出的重定向。比如我们将1指向文件，那么标准的输出就会输出到文件中。

## 输出重定向

输出重定向的使用方式很简单，基本的一些命令如下：

| 命令                | 介绍                       |
| ------------------- | -------------------------- |
| command >filename   | 把标准输出重定向到新文件中 |
| command 1>filename  | 同上                       |
| command >>filename  | 把标准输出追加到文件中     |
| command 1>>filename | 同上                       |
| command 2>filename  | 把标准错误重定向到新文件中 |
| command 2>>filename | 把标准错误追加到新文件中   |

我们使用`>`或者`>>`对输出进行重定向。符号的左边表示文件描述符，**如果没有的话表示1，也就是标准输出**，符号的右边可以是一个文件，也可以是一个输出设备。当使用`>`时，会判断右边的文件存不存在，如果存在的话就先删除，然后创建一个新的文件，不存在的话则直接创建。但是当使用`>>`进行追加时，则不会删除原来已经存在的文件。

## 输入重定向

在理解了输出重定向之后，理解输入重定向就会容易得多。对输入重定向的基本命令如下：

| 命令                | 介绍                                      |
| ------------------- | ----------------------------------------- |
| command <filename   | 以filename文件作为标准输入                |
| command 0<filename  | 同上                                      |
| command <<delimiter | 从标准输入中读入，直到遇到delimiter分隔符 |

我们使用`<`对输入做重定向，**如果符号左边没有写值，那么默认就是0**。



## 高级用法

### 重定向绑定

好了，在有了以上知识的基础上，我们再来看开头提到的`>/dev/null 2>&1`。这条命令其实分为两命令，一个是`>/dev/null`，另一个是`2>&1`。

#### 1. >/dev/null

这条命令的作用是将标准输出1重定向到/dev/null中。/dev/null代表linux的空设备文件，所有往这个文件里面写入的内容都会丢失，俗称“黑洞”。那么执行了`>/dev/null`之后，标准输出就会不再存在，没有任何地方能够找到输出的内容。

#### 2. 2>&1

这条命令用到了重定向绑定，采用&可以将两个输出绑定在一起。这条命令的作用是错误输出将和标准输出同用一个文件描述符，说人话就是错误输出将会和标准输出输出到同一个地方。

linux在执行shell命令之前，就会确定好所有的输入输出位置，并且从左到右依次执行重定向的命令，所以`>/dev/null 2>&1`的作用就是让标准输出重定向到/dev/null中（丢弃标准输出），然后错误输出由于重用了标准输出的描述符，所以错误输出也被定向到了/dev/null中，错误输出同样也被丢弃了。执行了这条命令之后，**该条shell命令将不会输出任何信息到控制台，也不会有任何信息输出到文件中**。

### >/dev/null 2>&1 VS 2>&1 >/dev/null

再回到文章的开头，我说我弄反了`>/dev/null`和`2>&1`拼装的顺序，导致出了一点小问题。乍眼看这两条命令貌似是等同的，但其实大为不同。刚才提到了，linux在执行shell命令之前，就会确定好所有的输入输出位置，并且从左到右依次执行重定向的命令。那么我们同样从左到右地来分析`2>&1 >/dev/null`：

1. 2>&1，将错误输出绑定到标准输出上。由于此时的标准输出是默认值，也就是输出到屏幕，所以错误输出会输出到屏幕。
2. \>/dev/null，将标准输出1重定向到/dev/null中。

我们用一个表格来更好地说明这两条命令的区别：

| 命令            | 标准输出 | 错误输出 |
| --------------- | -------- | -------- |
| >/dev/null 2>&1 | 丢弃     | 丢弃     |
| 2>&1 >/dev/null | 丢弃     | 屏幕     |

### >/dev/null 2>&1 VS >/dev/null 2>/dev/null

那么可能会有些同学会疑问，为什么要用重定向绑定，而不是像`>/dev/null 2>/dev/null`这样子重复一遍呢。

为了回答这个问题，我们回到刚才介绍输出重定向的场景。我们尝试将标准输出和错误输出都定向到out文件中：

# ls a.txt b.txt >out 2>out# cat outa.txt�法访问b.txt: 没有那个文件或目录

WTF？竟然出现了乱码，这是为啥呢？这是因为采用这种写法，标准输出和错误输出会抢占往out文件的管道，所以可能会导致输出内容的时候出现缺失、覆盖等情况。现在是出现了乱码，有时候也有可能出现只有error信息或者只有正常信息的情况。不管怎么说，采用这种写法，最后的情况是无法预估的。

而且，由于out文件被打开了两次，两个文件描述符会抢占性的往文件中输出内容，所以整体IO效率不如`>/dev/null 2>&1`来得高。

### nohup结合

我们经常使用`nohup command &`命令形式来启动一些后台程序，比如一些java服务：

# nohup java -jar xxxx.jar &

为了不让一些执行信息输出到前台（控制台），我们还会加上刚才提到的`>/dev/null 2>&1`命令来丢弃所有的输出：

# nohup java -jar xxxx.jar >/dev/null 2>&1 &

## 总结

本文主要介绍了linux重定向的原理以及一些基本命令，并且详细地分析了`>/dev/null 2>&1`这个命令以及一些注意点。

总而言之，在工作中用到最多的就是`nohup command >/dev/null 2>&1 &`命令，希望大家能够好好掌握。

## 参考资料

1. [linux重定向总结](http://www.cnblogs.com/chengmo/archive/2010/10/20/1855805.html)
2. [>/dev/null 2>&1 和 2>&1 >/dev/null的区别](http://blog.csdn.net/reyleon/article/details/11595985)



**1. 关于文件和目录**

-f  判断某普通文件是否存在

-d  判断某目录是否存在

-b  判断某文件是否块设备

-c  判断某文件是否字符设备

-S  判断某文件是否socket（待修正）

-L  判断某文件是否为符号链接（待修正）

-e  判断某东西是否存在（待修正）

-p  判断某文件是否为pipe 或是 FIFO

**2. 关于文件的属性**

-r  判断文件是否为可读的属性

-w  判断文件是否为可以写入的属性

-x  判断文件是否为可执行的属性

-s  判断文件是否为非空白文件

-u  判断文件是否具有SUID的属性

-g  判断文件是否具有SGID的属性

-k  判断文件是否具有sticky bit的属性

**3. 两个文件之间的判断与比较**

例如[ test file1 -nt file2 ]

-nt  第一个文件比第二个文件新

-ot  第一个文件比第二个文件旧

-ef  第一个文件与第二个文件为同一个（ link 之类的文件）

**4. 逻辑的(and)与(or)**

&&   逻辑的 AND 的意思, -a 也是这个意思

||  逻辑的 OR 的意思， -o 也是这个意思

**5.运算符相关**

运算符号代表意义

=  等于  应用于：整型或字符串比较 如果在[] 中，只能是字符串

!=  不等于 应用于：整型或字符串比较 如果在[] 中，只能是字符串

<  小于 应用于：整型比较 在[] 中，不能使用 表示字符串

\>  大于 应用于：整型比较 在[] 中，不能使用 表示字符串

-eq  等于 应用于：整型比较

-ne  不等于 应用于：整型比较

-lt  小于 应用于：整型比较

-gt  大于 应用于：整型比较

-le  小于或等于 应用于：整型比较

-ge  大于或等于 应用于：整型比较

-a  双方都成立（and） 逻辑表达式 –a 逻辑表达式

-o  单方成立（or） 逻辑表达式 –o 逻辑表达式

-z  空字符串

-n  非空字符串

**6.1 test 命令**

\# test 1 = 1 && echo 'ok'

ok

\# test -d /etc/ && echo 'ok'

ok

\# test 1 -eq 1 && echo 'ok'

ok

\# if test 1 = 1 ; then echo 'ok'; fi

ok

**注意：所有字符 与逻辑运算符直接用“空格”分开，不能连到一起。test 1=1就是错误的！**

**6.2 [] 表达式**

 \# [ 1 -eq 1 ] && echo 'ok'

ok

\# [ 2 < 1 ] && echo 'ok'

-bash: 2: No such file or directory

\# [ 2 \< 1 ] && echo 'ok'

\# [ 2 -gt 1 -a 3 -lt 4 ] && echo 'ok'

ok

\# [ 2 -gt 1 && 3 -lt 4 ] && echo 'ok'

-bash: [: missing `]'

**注意：在[] 表达式中，常见的>, <需要加转义字符，表示字符串大小比较，以acill码 位置作为比较。**

**不直接支持<, >运算符，还有逻辑运算符|| , && 它需要用-a[and] –o[or]表示**

**6.3 [[]] 表达式**

\# [ 1 -eq 1 ] && echo 'ok'

ok

\# [[ 2 < 3 ]] && echo 'ok'

ok

\#[[ 2 < 3 && 4 > 5 ]] && echo 'ok'

ok

 [[ 2 < 3 -a 3 > 4 ]] && echo "ok"

-bash: syntax error in conditional expression

-bash: syntax error near `-a'

**注意：[[]] 运算符只是[]运算符的扩充。能够支持<,>符号运算不需要转义符，它还是以字符串比较大小。里面支持逻辑运算符：|| && ，不再使用-a -o**

华丽丽的分割线

**********************************************************************************************************************************************

 另外一部份总结：

**bash shell中` `与[ ]的区别**

**一，[[用"&&"而不是"-a"表示逻辑"与"，用"||"而不是"-o"表示逻辑"或":**

\# [[ 1 < 2 && b > a ]] && echo true || echo false

true

\# [[ 1 < 2 -a b > a ]] && echo true || echo false

bash: syntax error in conditional expression

bash: syntax error near `-a’

\# [ 1 < 2 -a b > a ] && echo true || echo false

true

\# [ 1 < 2 && b > a  ]&& echo true || echo false #wrong syntax

bash: [: missing `]‘

false

|            | [[]] | []           |
| ---------- | ---- | ------------ |
| -a或者-o   |      | 语法合法     |
| &&或者\|\| | 合法 |              |
| ==         |      | 只能是字符串 |
|            |      |              |
|            |      |              |
|            |      |              |
|            |      |              |



**二，[ ... ]为shell命令，所以在其中的表达式应是它的命令行参数，所以串比较操作符”>” 与”<”必须转义，否则就变成IO改向操作符了。[[中"<"与">"不需转义：**

\#  [ 2 \< 10 ] && echo true || echo false  #you should use “\<”

false



\#[ 2 -lt 10 ] && echo true || echo false

true



\#  [[ 2 < 10 ]] && echo true || echo false

false

**三，` `.``.``.` `进行算术扩展，而[ ... ]不做。**

\#  [[ 99+1 -eq 100 ]] && echo true || echo false

true

\#  [ 99+1 -eq 100 ] && echo true || echo false

bash: [: 99+1: integer expression expected

false

\#  [ $((99+1)) -eq 100 ] && echo true || echo false

true

**四，[[]]能用正则，而[]不行**

\# [ "test.php" == *.php ] && echo true || echo false

false

\# [[ "test.php" == *.php ]] && echo true || echo false

true

\# [[ "t.php" == [a-z].php ]] && echo true || echo false

true

\# [ "test.php" == "*.php" ] && echo true || echo false

false

\# [[ "test.php" == "*.php" ]] && echo true || echo false

false

注意：双引号（"")的作用



# 小知识点

| 小知识点       | 用法                                                         |
| -------------- | ------------------------------------------------------------ |
| 获取命令的结果 | 用 ``把命令包含起来                                          |
| 输出结果重定向 | >/dev/null 2>&1                                              |
| 删除变量       | unset  使用时不加$                                           |
| declare命令    | declare [+/-][选项] 变量名<br/>选项：
-：给变量舍得类型属性
+：取消变量的类型属性
-a：将变量声明为数组型
-i：将变量声明为整型
-x：将变量声明为环境变量
-r：将变量声明为只读变量
-p：查看变量的被声明的类型 |
|                |                                                              |
|                |                                                              |
|                |                                                              |
|                |                                                              |
|                |                                                              |



```shell
eg:
tmp=`echo 123`
echo $tmp

结果为：123
eg: unset
  TEST='test'
  echo $TEST
  输出：test
  unset TEST
  echo $TEST
  输出：空

```



# shell单例运行

```shell
# 确保进程为单例 
function keep_singleton()
{
	tmpfile="/tmp/ps_out_$$"
	ps aux | grep ${1} | grep -v $$ | grep -v grep | grep -v 'sh -c' | awk '{print $2}' > $tmpfile
	pids=`cat $tmpfile`
	rm -rf $tmpfile
	if [ -n "$pids" ]; then
		echo "another program is running"
		exit 99
	fi
}

keep_singleton ${0} # ${0}shell脚本名
```

# 数组注意问题

| 成员的获取和计算 | MEM_USED=`expr ${MEM_ARR[0]} - ${MEM_ARR[1]} - ${MEM_ARR[2]} - ${MEM_ARR[3]}` |
| ---------------- | ------------------------------------------------------------ |
|                  |                                                              |
|                  |                                                              |
|                  |                                                              |

# awk

| 循环取一列并进行处理 | awk 'BEGIN{val=0}{val+=$4}END{printf("%.0lf", val)} |
| -------------------- | --------------------------------------------------- |
|                      |                                                     |
|                      |                                                     |
|                      |                                                     |



